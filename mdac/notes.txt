You are building a digital lock,
 the kind you’d see on a door keypad
 but as if you were designing the hardware inside the chip,
  not writing an app.


Listens to physical button signals (wires going high/low)
Remembers what state it’s in (locked, entering code, unlocked, etc.)
Decides what to do only on clock edges
Has no software, no variables, no arrays, no memory lookups

Is made of:
logic gates
flip-flops
wires

a finite state machine



mdac/
├── gates.v
├── decoder.v
├── comparator.v
├── invalid_input.v
├── dff.v
├── fsm.v
├── mdac_top.v
└── tb_mdac.v

Build pure logic first (no clock)

-- mdac top has template, study this
        describes the top level view of the whole thing from the outside

-- do gates.v, use assign concept, non sequential
-- VERILOG DOESNT RUN ITS NOT AN EXE, ITS A BLUEPRINT OF MODULES
-- A SIMULATOR RUNS IT AND PRETENDS THE GATES AND WIRES EXIST


instantiating a module
always declare wires
    wire w1;

and_gate my_and (
    .a(i), // connect the a pin of the AND gate (in the template) to the wire named i
    .b(j),
    .c(k)
);

Left side = pin name on the module
Right side = wire name in the parent module




Add memory (flip-flops)

Add the FSM